var searchIndex = JSON.parse('{\
"opg":{"doc":"Operator Precedence Grammar Parser<code>opg</code> reads an …","i":[[0,"dfs","opg","dfs<code>dfs</code> provides the way to make  three different …",null,null],[3,"Dfs","opg::dfs","A struct to make DFS movement in an OOP code style. And …",null,null],[12,"mono","","",0,null],[12,"con","","",0,null],[12,"visited","","",0,null],[12,"path","","",0,null],[12,"element","","",0,null],[12,"category","","",0,null],[12,"tree","","",0,null],[12,"top","","",0,null],[11,"new","","",0,[[["string",3],["hashset",3],["hashmap",3]],["dfs",3]]],[11,"dfs","","",0,[[],[["hashset",3],["hashmap",3],["string",3]]]],[11,"dfs_merge","","Merge DFS",0,[[["string",3]]]],[11,"dfs_conn","","connection DFS",0,[[["option",4],["string",3]]]],[11,"dfs_map","","map DFS",0,[[["hashset",3],["string",3]]]],[11,"merge","","Merge New Category",0,[[["string",3]]]],[5,"compose_elements","","Compose the elements from mono and con.",null,[[["hashmap",3]],[["hashset",3],["hashmap",3],["string",3]]]],[0,"table","opg","table<code>table</code> provides <code>OpTable</code> struct to make insert, output …",null,null],[3,"OpTable","opg::table","A struct of Operation Table.",null,null],[12,"table","","The hashmap of relation.",1,null],[12,"ts","","The terminal set in the grammar.",1,null],[11,"new","","Create a new <code>opTable</code>.",1,[[["hashset",3],["string",3]],["optable",3]]],[11,"insert","","Insert to table.",1,[[["char",15]]]],[11,"to_string","","Convert table to string.",1,[[],["string",3]]],[3,"Production","opg","A struct to  represent a production.",null,null],[12,"left","","the left side of the production.",2,null],[12,"right","","the right side of the production.",2,null],[5,"gen_firstvt","","Generate FIRSTVT set for every non-terminals.",null,[[["hashset",3],["vec",3]],[["hashset",3],["hashmap",3],["string",3]]]],[5,"gen_lastvt","","Generate LASTVT set for every non-terminals.",null,[[["hashset",3],["vec",3]],[["hashset",3],["hashmap",3],["string",3]]]],[5,"find_eq","","Find the equal operators",null,[[["hashset",3],["optable",3],["vec",3]]]],[5,"find_less","","Find the less relations",null,[[["optable",3],["vec",3],["hashmap",3],["hashset",3]]]],[5,"find_greater","","Find the greater relations",null,[[["optable",3],["vec",3],["hashmap",3],["hashset",3]]]],[5,"gen_productions","","Generate production list for the grammar contents.",null,[[["string",3]],[["vec",3],["production",3]]]],[5,"get_non_terminals","","Get all the non terminals from the generated production.",null,[[["vec",3]],[["hashset",3],["string",3]]]],[5,"get_terminals","","Get terminals",null,[[["hashset",3],["vec",3]],[["hashset",3],["string",3]]]],[5,"opg_generate","","Generate Operator Precedence Table for context-free …",null,[[["string",3]]]],[5,"main","","",null,[[]]],[11,"from","opg::dfs","",0,[[]]],[11,"into","","",0,[[]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"try_into","","",0,[[],["result",4]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"from","opg::table","",1,[[]]],[11,"into","","",1,[[]]],[11,"to_string","","",1,[[],["string",3]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"try_into","","",1,[[],["result",4]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"from","opg","",2,[[]]],[11,"into","","",2,[[]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"try_into","","",2,[[],["result",4]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"fmt","opg::table","Define the behavior of outputting an <code>opTable</code> struct.",1,[[["formatter",3]],["result",6]]]],"p":[[3,"Dfs"],[3,"OpTable"],[3,"Production"]]}\
}');
addSearchOptions(searchIndex);initSearch(searchIndex);